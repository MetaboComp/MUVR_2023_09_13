% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/permutations.R
\name{permutations}
\alias{permutations}
\title{Make permutations with data and default settings from an actual MUVR object}
\usage{
permutations(
  MUVRclassObject,
  nPerm = 50,
  nRep,
  nOuter,
  varRatio,
  parallel,
  permutation_type = c("AUROC", "MISS", "RMSEP", "BER")
)
}
\arguments{
\item{MUVRclassObject}{A 'MUVR' class obvject}

\item{nPerm}{number of permutations to run}

\item{nRep}{number of repetitions for each permutation (defaults to value of actual model)}

\item{nOuter}{number of outer validation segments for each permutation (defaults to value of actual model)}

\item{varRatio}{varRatio for each permutation (defaults to value of actual model)}

\item{parallel}{whether to run calculations using parallel processing - which requires registered backend (defaults to value of actual model)}
}
\value{
permutation_output: A permutation matrix with permuted fitness statistics (nrow=nPerm and ncol=3 for min/mid/max)

permutation_type: Either AUROC,Q2 or MISS or BER
}
\description{
This function will extract data and parameter settings from a MUVR object and run standard permutations.
This will fit a standard case of multivariate predictive modelling in either a regression, classification or multilevel case.
However, if an analysis has a complex sample dependency which requires constrained permutation of your response vector
or if a variable pre-selection is performed for decreased computational burden, then permutaion loops should be constructed manually.
In those cases, View(permutations) can be a first start from which to build custom solutions for permutation analysis.
}
\examples{
library(MUVR)
library(doParallel)
nCore=detectCores()-1
cl=makeCluster(nCore)
registerDoParallel(cl)
nRep=2*nCore
varRatio=.75
nOuter=6
nPerm=50
R12ML=MUVR(X=mlr12,ML=T,nRep=nRep,nOuter=nOuter,varRatio=varRatio,method='RF')
permR12=permutations(R12ML)
stopCluster(cl)
permutationPlot(R12ML,permR12)
}
